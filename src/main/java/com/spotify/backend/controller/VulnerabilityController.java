package com.spotify.backend.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import com.spotify.backend.repository.SongRepository;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/vulnerabilities")
public class VulnerabilityController {

    @Autowired
    private SongRepository songRepository;

    /**
     * DEMO: NoSQL Injection vulnerability (to be fixed in VIVA)
     */
    @GetMapping("/search-unsafe")
    public ResponseEntity<?> unsafeSearch(@RequestParam String query) {

        System.out.println("⚠️ VULNERABILITY: NoSQL Injection possible");

        // UNSAFE: Direct string concatenation (VULNERABLE)
        String unsafeQuery = "{title: {$regex: '.*" + query + ".*', $options: 'i'}}";
        System.out.println("Executing unsafe query: " + unsafeQuery);

        // Attack example: query = ".*' || '1'=='1
        // Resulting query: {title: {$regex: '.*.*' || '1'=='1.*', $options: 'i'}}

        return ResponseEntity.ok(Map.of(
                "vulnerability", "NoSQL Injection",
                "unsafeQuery", unsafeQuery,
                "risk", "HIGH - Can bypass authentication, extract all data",
                "attackVector", "Malicious regex injection",
                "fix", "Use parameterized queries with Criteria API"
        ));
    }

    /**
     * DEMO: Missing indexes - Common vulnerability
     */
    @GetMapping("/missing-indexes")
    public ResponseEntity<?> showMissingIndexes() {

        return ResponseEntity.ok(Map.of(
                "vulnerability", "Missing Critical Indexes",
                "impact", "Slow queries, high CPU usage, poor user experience",
                "commonMissingIndexes", List.of(
                        Map.of(
                                "collection", "songs",
                                "field", "artist_id",
                                "query", "Find songs by artist",
                                "current", "COLLSCAN (full collection scan)",
                                "solution", "Create single-field index on artist_id"
                        ),
                        Map.of(
                                "collection", "playlists",
                                "field", "createdBy",
                                "query", "Get user's playlists",
                                "current", "COLLSCAN",
                                "solution", "Index on createdBy"
                        ),
                        Map.of(
                                "collection", "user_likes",
                                "fields", Arrays.asList("userId", "songId"),
                                "query", "Check if user liked song",
                                "current", "COLLSCAN",
                                "solution", "Compound unique index on (userId, songId)"
                        )
                ),
                "diagnosisCommand", "db.currentOp({'secs_running': {$gt: 5}})",
                "monitoring", "Use MongoDB Atlas Performance Advisor or db.collection.explain()"
        ));
    }

    /**
     * DEMO: Over-indexing - Too many indexes
     */
    @GetMapping("/over-indexing")
    public ResponseEntity<?> showOverIndexing() {

        return ResponseEntity.ok(Map.of(
                "vulnerability", "Over-Indexing",
                "impact", "Slower writes, increased storage, maintenance overhead",
                "symptoms", List.of(
                        "Write operations taking longer than expected",
                        "Index storage > 50% of data storage",
                        "Duplicate or overlapping indexes"
                ),
                "exampleBadIndexes", List.of(
                        "Index on (A, B) AND index on (A, B, C) → Keep only (A, B, C)",
                        "Index on (A) AND index on (A, B) → Keep only (A, B)",
                        "Index on ascending and descending same field"
                ),
                "bestPractices", List.of(
                        "Use compound indexes instead of multiple single-field indexes",
                        "Remove indexes used by < 1% of queries",
                        "Use partial indexes for filtered queries",
                        "Monitor index usage with $indexStats"
                )
        ));
    }

    /**
     * DEMO: Missing index causing performance DoS
     */
    @PostMapping("/dos-simulation")
    public ResponseEntity<?> simulateDoS() {

        System.out.println("⚠️ VULNERABILITY: Missing indexes enabling DoS");

        // Simulate expensive query without index
        // In MongoDB: db.songs.find({genre: {$regex: '^A'}}).sort({playCount: -1})
        // Without index: COLLSCAN + SORT in memory

        return ResponseEntity.ok(Map.of(
                "vulnerability", "Denial of Service via expensive queries",
                "attack", "Request sorted queries on non-indexed fields",
                "impact", "High CPU/Memory consumption, slow response",
                "mitigation", "1. Create appropriate indexes 2. Query timeouts 3. Rate limiting"
        ));
    }

    /**
     * DEMO: Schema validation missing (polymorphic attacks)
     */
    @PostMapping("/schema-pollution")
    public ResponseEntity<?> schemaPollution() {

        System.out.println("⚠️ VULNERABILITY: No schema validation in MongoDB");

        // Attack: Insert document with extra fields
        // Example: Adding "isAdmin": true to user document

        return ResponseEntity.ok(Map.of(
                "vulnerability", "Schema injection / pollution",
                "example", "POST /api/users with {\"username\": \"attacker\", \"role\": \"SUPER_ADMIN\"}",
                "risk", "Privilege escalation, data corruption",
                "solution", "Implement JSON Schema validation in MongoDB"
        ));
    }

    /**
     * SOLUTION: Show how to fix vulnerabilities (for VIVA)
     */
    @GetMapping("/solutions")
    public ResponseEntity<?> showSolutions() {

        return ResponseEntity.ok(Map.of(
                "vulnerabilitiesFixed", List.of(
                        Map.of(
                                "vulnerability", "NoSQL Injection",
                                "fix", "Use Spring Data MongoDB Criteria API",
                                "code", "Query query = Query.query(Criteria.where(\"title\").regex(query, \"i\"));"
                        ),
                        Map.of(
                                "vulnerability", "Missing Indexes",
                                "fix", "Create compound indexes and explain() analysis",
                                "code", "@CompoundIndex(def = \"{'genre': 1, 'playCount': -1}\", name = \"genre_plays_idx\")"
                        ),
                        Map.of(
                                "vulnerability", "Schema Pollution",
                                "fix", "MongoDB JSON Schema validation",
                                "code", """
                    {
                      $jsonSchema: {
                        bsonType: "object",
                        required: ["username", "email"],
                        properties: {
                          role: {enum: ["USER", "ADMIN"]}
                        }
                      }
                    }
                    """
                        )
                )
        ));
    }
}